# FLXG 的秘密

公元 0xFB2 年, FLXG 正当其道.

没错, 在 CWK 的伟大倡导之下, 年份采用了更为先进的 16 进制表示. 中国滑稽大学也因为率先提出了 FLXG 的理论, 其世界超一流的院校的地位已经不可动摇. 而在肥宅路 98 号某个废弃的角落里 -- 实际上是两千年前一时风光无二, CWK 口中以考试分数为唯一目标的分院 -- 几名幸存的理论物理系跑男 (旧指为 GPA 而四处奔波的分院学生) 在饥寒交迫中, 企图谋划着最后的反抗.

实际上, 他们已经成功了. 多少代物理系的先辈们忍辱负重, 转入 CS, 就是为了制造出量子计算机, 试图攻破 FLXG 这个天衣无缝的理论. 这个计划已经实施了两千年, 而现在终于结成正果了. 世界上仅存的几位分院跑男, 他们已经掌握了 FLXG 最核心的秘密, 那是除了创始人 CWK 无人知晓的秘密, 那是失传千年的, 整个 FLXG 的唯一漏洞. 当年的 Nature, Science, 如今的 Engineer 期刊上不断有人试图找出这个纰漏, 然而所有人都失败了. (可惜也没人能够证明 FLXG 的绝对完美性) 因此 FLXG 有一段时间被认为是最接近真实的假设 -- 当然, 这是落后的理科思想所形成的结论. 所以, 正如你看到的这样, FLXG 已经成为了金科玉律一般的存在. 然而, 它的唯一漏洞, 在这一年, 已经这几名跑男找到了.

但是, 他们也是失败的. 分院和物院, 已经在滑稽大学的 FLXG 改革中消失, 所有留存的痕迹, 也成为校史馆中的笑料和反面教材. "什么? 你还跑过去找老师要分? 怕不是分院余孽.." 之前时时还能听到这样的嘲讽, 如今嘲讽的对象也越来越少, "分院跑男" 这种词已经被新版的 CWK 词典移到了附录里, 以后估计会被删掉的吧. 就算有人找到 FLXG 的秘密又怎么样呢, 再也不会有人去读物理了.

当然, 有唯一的一条出路, 就是设法把这条秘密发送到两千年前. 这样大家就能在 FLXG 的实施之前, 看到它的漏洞了, 也许就可以拯救分院和物院的命运了.

如今的技术发展, 虽然能够在一定程度上控制时空, 但是要把消息传回两千年前, 的确是不太靠谱. 何况两千年前的人类根本无法做出应答. 当然更关键的, 就是因果律的影响了. 传递消息的做法, 必须要瞒过因果律, 否则只会在过去的时间长河中开出一条小小的支流, 对于这个平行宇宙来说并无意义.

为了做到这一点, 他们几人把秘密用许多随机生成的锁保护起来, 最后连接成一个可以自动计算出秘密的程序 (他们为了存活也转行做 CS 了), 而这个程序运行起来需要 2000 年甚至更久. 之后, 他们再以四千年前的伏羲先天六十四卦将程序编码, 以此试图骗过因果律, 逆流而上, 成前人未有之壮举.

然而, 由于时间长河的冲刷, 这份信息仍然受到了损毁. 在 0x7E2 年的你, 能够解出 FLXG 的秘密吗?

[打开题目](src/flxg.txt)

---
### 来自未来的漂流瓶
##### TL;DR
六十四卦那些卦象，你们看着不觉得就像二进制吗..。
##### 详解
下下来直接打开发现乱码。不知道为啥编辑器不觉得这是 UTF-8。切换到 UTF-8 的编码，发现果然一堆六十四卦的名词。

无论怎么编码的，第一步肯定是把不同卦分离开来。六十四卦的名称比较杂乱，是变长的 CISC 架构，代码里面的六十四卦卦名要老老实实写出来。

接下来就是脑洞时间了。六十四卦每一卦都有 6 个 bits 的信息，而一般的数据都是以 8 个 bits 为单位。因此，我们看一下长度，发现可以被 8 整除，这进一步验证了我们的猜想。接下来，就是考虑如何把一个卦象转化为 6 个 bits。

有三类显而易见的情况:
* 每个卦象自下而上，阴阳对应 0 和 1，这就是两种可能
* 每个卦象自上而下，阴阳对应 0 和 1，这又是两种可能
* 卦象以先天六十四卦顺序，也是 Unicode 字符集中的顺序编码

写出来脚本跑一跑，发现第二种情况能产生一个 gzip 的文件。解压时提示文件损坏，查看文件末尾即可得到 flxg。
### 难以参悟的秘密
##### TL;DR
Merkle Hellman Knapsack Cryptosystem
##### 详解
本题是一道逆向。

解压得到一个可执行文件和一堆动态链接库。拖进 IDA 里发现，程序会读取 passkey.txt 的内容，然后通过调用动态链接库的函数进行校验。最后经过一番处理，每 8 行变成一个大整数。然后根据一个 128bit 的数的某一位进行求和。最后判断是否结果等于最后一个大整数。这实际上是一个 Merkle Hellman Knapsack Cryptosystem。

二进制里重要函数都已经标注出来。一旦我们弄清楚程序的意图，就可以继续做下去了。思路非常清晰: 先要恢复 passkey.txt 的内容，进而得到每个大整数。然后求解 flxg。

第一步，需要选手批量处理动态链接库中的代码。动态链接库里面的验证基本可以总结为 kx+b=x，通过将 k 和 b 提取出来，可以求解 x。而 k 和 b 两个数字在 lock 函数中偏移固定，可以通过能处理 ELF 的 python 库或二进制分析框架提取出来。

第二步，我们得到了 passkey.txt 应有的内容。现在我们需要还原 128 个大整数。大致有两种思路，一种是动态运行程序，通过修改程序的代码或者 Hook 或者 DBI 或者调试器脚本的方法，可以得到这些大整数。另一种是通过逆向，自己重现相应的算法。这道题里面使用了一个不常见的 Hash 算法 -- JH，很难识别出来。并且代码中大量使用 SSE，很难手动实现。但是可以通过将可执行文件转为动态链接库的方法导出相关函数，从而直接运行程序的算法。

第三步，Low Density attack。这实际上是 1984 年的攻击了。需要找到论文简单复现一下即可。比如 http://www4.ncsu.edu/~smsulli2/MA437_Fall2017/knapsack.pdf。其核心思想是构造出一个 Lattice，这些向量加起来和为 0。然后就变成了格点规约问题了。通过 LLL 算法很容易求出解。

(此处省略丑陋的 Mathematica 代码)

本题代码见 flxg.c 与 lock.c。代码实际上不能直接编译，因为缺少 jh.h (只是一个 hash 算法的实现) 和 lock.h (由脚本生成)。不过大致流程比较清晰。可参看。
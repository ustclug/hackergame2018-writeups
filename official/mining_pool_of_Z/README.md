# 家里有矿

<p style="color:red;">提示：</p>
<p style="color:red;">1. 本题的浏览器“挖矿”只为演示性目的，几乎不占资源。我们不会以任何形式盗取或浪费大家电脑的算力。</p>
<p style="color:red;">2. 本题如果使用程序求解，对于普通配置的个人电脑，在解法正确且最优的情况下，求解程序的期望运行时间不会超过几分钟。</p>

Z 同学为了赶上区块链的热潮，自己潜心研究工作量证明（Proof of work）算法，并且发布了三种全新的电子货币。不仅如此，他还写了一个矿池。

给专业选手的注释：此题并非 web 题，解题过程不涉及注入、XSS、敏感文件泄露、弱类型等安全问题。

[打开题目](http://202.38.95.46:12006/)

---

这道题是我出题花费时间最多，也是我最喜欢的一道题目。我暑假期间编写题目网站、调节每种 Hash 算法的难度、写解题代码、与其他人讨论是否有非预期解法等等，前前后后花了很多天的时间。

## 解题思路

所谓我发明的新的工作量证明算法，就是服务器给出一个后缀 `suffix`，我需要生成两个随机字符串 `nonce1` 和 `nonce2`，使得 `hash(nonce1+suffix)` 和 `hash(nonce2+suffix)` 相同的二进制位数量超过某一个值，这个值对于不同的 Hash 算法是不一样的

### SHA1

直接在 Google 搞出来的 sha1 碰撞 [那两个 pdf](https://shattered.io/) 后面加上 `suffix` 提交即可，因为是 Hash 碰撞，所以所有二进制位都是相同的

### MD5

这次使用已有的 md5 碰撞加上后缀会发现不给你 flag 了。期望解法有两种，一种是按照王小云的论文搞出来一个不完全的碰撞（我没研究），另一种是真的穷举。

我是用 C 语言写的穷举程序。为了偷懒，我在 python 解题脚本中生成了一堆 md5 写入一个二进制文件，然后调用 C 程序来穷举，C 程序就只需要算异或和统计二进制位的个数了。在 C 语言中使用 `__builtin_popcountll` 函数统计二进制位中 1 的个数，一条 POPCNT 指令就可以统计 64 bit，速度很快，一分钟之内有很大概率可以跑出来。听说有的同学还使用了 GPU 穷举，关于优化这块大家就各显神通了。

### SHA256

穷举是不可能的，即使你用大型超算都不太可能在比赛时间内跑出来。所以呢？期望解法是从比特币的区块链里面找数据。比特币的工作量证明算法是 sha256，现在区块链里面的每一个区块哈希前面都有大约 80 个二进制 0（多么疯狂啊），所以拿它们来找共同 bit 数很多的哈希值，自带了大约 40 位的加成（因为本来 80 位在期望上也有 40 位是相同的）。你需要想办法下载比特币所有区块的哈希，然后两两配对来看一下相同的 bit 数量。如果达到了题目要求，就是下载它们的区块头部，区块头部的两次 sha256 就是最终的 hash，你需要计算一次 sha256，然后结果就是你要提交的数据。不过，我们还是需要满足一个字符的 suffix 要求，这个只要你不断 getjob，总是可以很快拿到你想要的 suffix 的。

解题脚本：https://github.com/zzh1996/mining_pool_of_Z/blob/master/solution/solve.py

注：我设计题目和分析的过程都可以在上面这个仓库中找到
